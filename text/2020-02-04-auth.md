# Auth for applications

## Summary

TiKV authentication and authorization can be implemented by leveraging

* key space registration
* token signing
* delegation

PD maintains key spaces and signs tokens for clients that authenticate.
TiKV verifies the tokens.
Clients may delegate their tokens to permit direct TiKV access for users in their own auth system.

This can solve the most pressing auth concerns without attempting to

* push down TiDB's auth into TiKV
* develop a separate RBAC in TIKV


## Motivation

TiKV currently has no concept of authentication.
TiDB supports authentication.
This has been done in the TiDB layer probably in partly because it is a large effort to achieve MySQL compatible auth mechanisms.
However, TiKV exposes its data over a network connection, whereas MySQL storage does not.

This means that any attacker that can connect to a TiKV node can exfiltrate all its data.
This risk can be mitigated by the usage of TiKV's support for mutual TLS authentication.
TLS can identify a client by its certificate, but without auth in TiKV, this just verifies that it came from a trusted CA.
So every connected client is effectively a root user.
There is also risk that the certificate issuance is not properly closed to TiKV clients since we don't identify the clients that connect.

We want TiKV to be used as a stand-alone project.
This means that TiKV network access to more diverse clients than just PD/TiDB is a requirement.
Essentially every client must implement their own auth just as TiDB has done.
And all these client machines with the ability to access TiKV must be trusted as root users.


## Detailed design

#### Key Spaces and user spaces

I first want to establish the concept of a “key space”.
TiDB is one potential user of TiKV.
One also might want to run 2 entirely separate TiDB clusters against the same TiKV cluster or run other applications against TiKV.
To have multiple applications use TiKV without impeding each other, we need each to have a different key prefix.
This concept can be formalized as a “key space”, where an application is registered for a key space, and TiKV transparently maps this key space to a key prefix.
Users in TiKV will be the combination of a name and a key spaces.

I submitted a [Key Spaces RFC](https://github.com/tikv/rfcs/pull/39).


#### PD as the authenticator and authorizer

This solution uses the concept of a signed token.
This pattern is becoming more prevalent and these tokens are concretely sometimes a JWT (or a more secure JWT derivative) or a macaroon.
The key pattern is that an identity broker produces a token.
This token can be used with different services without the need for the services to contact the identity broker.
In our case, PD will be the identity broker, and TiKV is the service that the token is sent to.

* PD contains a database of users and key spaces that they own. When a client (TiDB SQL) first connects, it must register a user, a key space, and its authentication information (e.g. password). This information could also potentially be seeded by data import or a root user.
* All TiKV clients must first authenticate with PD.
* PD sends back a cryptographically signed token to the client. This means that the token cannot be tampered
* This token includes as metadata the key space of allowed key access
* The client then sends this token with it’s requests to TiKV
* TiKV decrypts the token.
  * Failure: A decryption failure means the token is expired or was tampered with, and the client is denied access.
  * Success: The client is authenticated. TiKV performs authorization by 1 looking at the included metadata to ensure that the client is operating on the keys that it is allowed to. If not, the request is denied.

I think the above overview is easy to understand. There are still a lot of implementation details to review.


#### Shared secret initialization

In the above scenario, TiKV must have a mechanism to be able to decrypt the token and ensure it was not tampered with.
One way of doing this is to encrypt it with a secret that only TiKV knows.
At startup, TiKV can get the secret from PD.
However, we must be able to prevent impersonation of a TiKV node, and we can do this with our existing auth mechanism

TiKV itself must also authenticate.
PD must be configured with a TiKV user before it can store data in TiKV.
This user just like any other will require a CA cert or a password.


#### Reducing overhead

Auth will create some additional latency for new requests.
However, I don’t think it needs to create any noticeable overhead for long-lived connections.
TiDB gets a token from PD that can be used for some time period (perhaps 15 minutes).
In the background during that 15 minutes TiDB will renew its token and then switch to the renewed token.
If a long-lived connection can switch to the new token while still connected, then we can avoid disrupting long-lived connections.
Short-lived connections and re-connections can also be optimized In TiKV by caching successfully decrypted tokens.

#### Flushing changes

If the token remains valid to TiKV for 15 minutes, how do we handle making changes to user permissions take effect sooner? There are 2 concerns here

* Logout (early expiration)
* Key space deletion

To force an immediate logout PD would need to broadcast a token expiration message to TiKV.
I don’t know if PD already does this kind of thing, but messages could be broadcast in a response during normal heartbeat operations.
Key space deletion is discussed in the Key Space RFC.

#### Transitioning TiDB auth

TiDB can use a single TiDB user registered in PD.
This will reduce the benefit of TiKV to just authentication and not take advantage of authorization at the TiKV level.
It is an open question as to what we would gain by pushing TiDB users down to PD.
I believe this weakens security for 2 reasons

* If we cannot express the authorization restrictions in PD, then we effectively weaken security.
* This would allow a TiDB user additional direct access to TiKV, which we would have to figure out how to restrict.

It is possible that storing more users in TiKV could be useful the purpose of simplifying user management if they are running multiple clients (e.g. multiple separate TiDB tenants with different key spaces) against a single TiKV. However, in some sense the fact that this is about users is not important, the important thing is that 2 TiDB tenants want to share some of their data, and a more general mechanism is warranted here.


#### Authorization just for key spaces?

Database interfaces like TiDB that can implement their own auth and only need authorization for key space access.
However, there is a use case I can think of to not limit ourselves to just key space access.

* Restricting access of data retrieval mechanisms that use TiDB data but do not actually access the data through TiDB, and only access a subset of the data or only read the data.

Our current tools include TiSpark, TiFlash, backup, and replication.
Adding users in TiKV in this case would allow for direct access and we would want to be able to place appropriate access restrictions.
However, an alternative implementation to adding TiKV users for this problem is that of delegation.
These tools that need direct TiKV access must first login to TiDB.
TiDB can then give them a signed token for accessing TiKV.
This token is recognized by TiKV as delegated by the TiDB user.
The token also includes access restrictions given by TiDB (remember that tokens are signed and therefore cannot be tampered with).
For example the restrictions would be further key range restrictions or read-only access.
This allows TiDB to dynamically change access restrictions for these users without updating user entries in TiKV.
So TiKV users should be registered with just key space restrictions and do not need further restrictions registered.
TiKV itself though can support enforcing further access restrictions set in delegation tokens.
The auth token will carry the key spaces that the client registered.
TiKV will resolve these key spaces into key ranges by keeping a cache of this information from PD (see the flushing discussion above)

Another use case is applications that just want a simple KV store and want to share their access, but possibly with some restrictions.
As per above, it is preferred to share via delegation.
This works well for database layers like TiDB.
However, if multiple applications are just using TiKV as a KV store to share state, it may be less clear who is the rightful owner of the key space.
Sharing with full access should be possible by allowing multiple applications (with their own TiKV users) to have full access to a key space.
And we may end up wanting to support placing additional restrictions (read-only access and even more fine-grained key range restrictions).
However, I think all of this can be accommodated in the current design by gradually adding these features on top of the existing system that still starts with just a single key space owner and delegation.



## Drawbacks

This approach asks more of clients. We will need to ensure that all client libraries implement the auth outlined here.

## Alternatives

#### Titan

Titan is Redis implemented on top of TiKV.
It implements signed tokens with namespace restrictions.
This is very similar in spirit to this proposal but implemented in a way that is Redis compatible.
Some information is [available here](https://medium.com/@shafreeck/titan-a-distributed-redis-protocol-compatible-nosql-database-4379a1307661).


#### Etcd

Etcd has [users and roles](https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/authentication.md#working-with-roles).
Users have passwords and roles give access to a key range.

I consider this the default design of auth for a KV store.
The design here takes some slightly different approaches that I think are better for a KV store designed to be used by applications.
Managing both users and key ranges in such an RBAC key range system would be more difficult for a multi-application database.
The Etcd implementation does have key ranges as first class objects that can be named, whereas key spaces effectively give this.
I also assume that delegation does not exist.

* Etcd requires a root role to create all users. In the TiKV design here, an application can simply claim a key space and setup auth for the keyspace itself.
* The root role must properly manage key ranges to ensure they don’t accidentally overlap
* The root role must manage multiple accessors of the same keys. The design here for TiKV gives ownership to an application and allows it to be in charge of delegating access. If centralization is still desired rather than delegation for some use cases, key spaces still provide a better starting point to ensure that key ranges do not go out of sync and are bounded

The advantage of the etcd implementation is the ability to create roles with fine-grained permissions.


#### FoundationDB

FoundationDB does not implement auth. It is suggested to implement this at the “layer” level (TiDB would be called a SQL layer), with someone even suggesting that auth in a memory unsafe language could be circumvented. They released a document (MongoDB) layer, but it has no auth, and I don’t see auth for their record layer either. We probably can’t know how Apple actually does auth themselves, and it appears likely that the 2-3 other public FoundationDB users may also not be using auth.
FoundationDB is interested in implementing auth, and key range restriction is mentioned here: https://github.com/apple/foundationdb/issues/1419
There is community interest in this feature, with someone [even prototyping an implementation](https://forums.foundationdb.org/t/introducing-the-redis-protocol-fdb-gateway/1320/5)
And other users [ask for the feature](https://forums.foundationdb.org/t/proxy-layer-for-securing-the-cluster/1611/9)

Note that FoundationDB does not have a separate PD. Because we do, the signed token part of the implementation is much more important for us.
FDB does have key spaces via their directory layer. However, the implementation as a client-side layer is problematic because it adds latency (since the key range for the directory alias is actually mutable).



## Unresolved questions

Important details are not detailed in this proposal yet
* the actual authentication mechanisms available
* the token signing mechanisms.

There are some issues we need to think about around root privilige and recovery of lost passwords.
This might extend to including TiKV restarts not requiring passwords.
